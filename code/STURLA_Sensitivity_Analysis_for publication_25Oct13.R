#' ============================================================================
#' STURLA Sensitivity Analysis: Figure Generation and Statistical Analysis
#' ============================================================================
#' 
#' This script generates all figures and statistical analyses for:
#' Kremer, P., Weaver, D., & Stewart, J.D. (in review). 
#' Sensitivity of Urban Structure-Temperature Relationships to Grid Parameterization. 
#' Submitted to Ecological Infromatic. 
#'
#' Authors: Peleg Kremer, Dennis Weaver, Justin D. Stewart
#' Date: October 2025
#' Version: 1.0 - Publication Release
#' 
#' ============================================================================
#' MANUSCRIPT FIGURES GENERATED
#' ============================================================================
#' 
#' Figure 2: Number of unique classes by resolution and angle
#' Figure 3: Ranking of top 5 STURLA classes (heatmaps)
#' Figure 4: Rank dynamics of most abundant classes
#' Figure 5: Class composition and diversity (stacked bar charts)
#' Figure 6: Class stability analysis (3 panels)
#' Figure 7: Mean surface temperature by STURLA class (heatmaps)
#' Figure 8: Temperature prediction performance (R² analysis)
#' Figure S1: Cumulative proportions (supplementary material)
#' 
#' ============================================================================
#' REQUIRED INPUT FILES
#' ============================================================================
#' 
#' This script requires three CSV files (provided as supplemental data):
#' 
#' 1. sturla_organized_counts.csv
#'    - Columns: resolution, angle, [STURLA class columns with counts]
#'    - Contains the count of grid cells for each STURLA class
#'    - Generated by Grid_STURLA_ST_for_publication.R or provided as supplemental data
#' 
#' 2. sturla_organized_ranking.csv
#'    - Columns: resolution, angle, [STURLA class columns with ranks]
#'    - Contains the rank (1 = most abundant) of each STURLA class
#'    - Derived from counts data
#' 
#' 3. sturla_organized_temps.csv
#'    - Columns: resolution, angle, [STURLA class columns with temperatures]
#'    - Contains mean surface temperature (°C) for each STURLA class
#'    - Averaged across all grid cells of each class
#' 
#' STURLA CLASS ABBREVIATIONS:
#' T = Tree canopy, G = Grass/shrubs, B = Bare soil, W = Water, P = Paved surfaces
#' L = Low-rise buildings (1-3 stories), M = Mid-rise (4-9 stories), H = High-rise (>9 stories)
#' Example: TGPL = cells containing Trees, Grass, Paved surfaces, and Low-rise buildings
#' 
#' ============================================================================

# Clear workspace and set options
rm(list = ls())
options(stringsAsFactors = FALSE)
options(scipen = 999)  # Disable scientific notation

#' ============================================================================
#' PACKAGE DEPENDENCIES
#' ============================================================================

required_packages <- c("tidyverse", "vegan", "viridis", "gridExtra", 
                       "ggplot2", "dplyr", "tidyr", "forcats", 
                       "RColorBrewer", "cowplot")

# Check for missing packages
missing_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]

if(length(missing_packages) > 0) {
  cat("\nMissing required packages:", paste(missing_packages, collapse = ", "), "\n")
  cat("Install them using: install.packages(c('", 
      paste(missing_packages, collapse = "','"), "'))\n\n")
  stop("Please install missing packages before running this script.")
}

# Load libraries
suppressPackageStartupMessages({
  library(tidyverse)
  library(vegan)
  library(viridis)
  library(gridExtra)
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  library(forcats)
  library(RColorBrewer)
  library(cowplot)
})

cat("\n=== STURLA SENSITIVITY ANALYSIS ===\n")
cat("Figure Generation Script\n")
cat("Started at:", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "\n\n")

#' ============================================================================
#' USER CONFIGURATION - MODIFY THESE PATHS FOR YOUR SETUP
#' ============================================================================

# Set base directory
# USERS: Modify this to point to your working directory
base_dir <- "."  # Current directory
setwd(base_dir)

# Data folder containing the three CSV files
# USERS: Modify this if your data files are in a different location
data_path <- "data"  # Folder containing sturla_organized_*.csv files

# Output folder for figures
output_dir <- "Figures"

# Create output directory if it doesn't exist
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  cat("Created output directory:", output_dir, "\n")
}

#' ============================================================================
#' DATA LOADING AND VALIDATION
#' ============================================================================

cat("\n=== LOADING DATA ===\n")

# Define expected filenames
counts_file <- file.path(data_path, "sturla_organized_counts.csv")
rankings_file <- file.path(data_path, "sturla_organized_ranking.csv")
temps_file <- file.path(data_path, "sturla_organized_temps.csv")

# Validate that all required files exist
if (!file.exists(counts_file)) {
  stop("Counts file not found: ", counts_file, 
       "\nPlease ensure the file is in the correct location.")
}
if (!file.exists(rankings_file)) {
  stop("Rankings file not found: ", rankings_file,
       "\nPlease ensure the file is in the correct location.")
}
if (!file.exists(temps_file)) {
  stop("Temperatures file not found: ", temps_file,
       "\nPlease ensure the file is in the correct location.")
}

# Load data files
cat("Loading data from:", data_path, "\n")
counts <- read.csv(counts_file)
rankings <- read.csv(rankings_file)
temps <- read.csv(temps_file)
cat("  Counts data:", nrow(counts), "rows\n")
cat("  Rankings data:", nrow(rankings), "rows\n")
cat("  Temperature data:", nrow(temps), "rows\n")

# Remove 'X' column if it exists (common R artifact)
if("X" %in% names(counts)) counts <- counts %>% select(-X)
if("X" %in% names(rankings)) rankings <- rankings %>% select(-X)
if("X" %in% names(temps)) temps <- temps %>% select(-X)

# Data quality control: filter out anomalous resolution values
# (removes any erroneous values starting with "997")
counts <- counts %>% filter(!str_detect(as.character(resolution), "^997"))
rankings <- rankings %>% filter(!str_detect(as.character(resolution), "^997"))
temps <- temps %>% filter(!str_detect(as.character(resolution), "^997"))

cat("Data loaded and validated successfully\n")
cat("Unique resolutions:", length(unique(counts$resolution)), "\n")
cat("Unique angles:", length(unique(counts$angle)), "\n")

#' ============================================================================
#' FIGURE 2: NUMBER OF UNIQUE CLASSES BY RESOLUTION AND ANGLE
#' ============================================================================

cat("\n=== CREATING FIGURE 2 ===\n")
cat("Number of unique STURLA classes vs resolution and angle\n")

# Function to count unique STURLA classes
count_unique_classes <- function(data, group_var) {
  class_cols <- names(data)[!names(data) %in% c("angle", "resolution")]
  
  data %>%
    group_by(!!sym(group_var)) %>%
    summarise(across(all_of(class_cols), sum, na.rm = TRUE), .groups = "drop") %>%
    pivot_longer(cols = -!!sym(group_var), names_to = "class", values_to = "count") %>%
    filter(count > 0) %>%
    group_by(!!sym(group_var)) %>%
    summarise(unique_classes = n_distinct(class), .groups = "drop")
}

# Calculate unique classes for resolution and angle
class_stats_resolution <- count_unique_classes(counts, "resolution")
class_stats_angle <- count_unique_classes(counts, "angle")

# Determine consistent y-axis limits
max_classes <- max(c(class_stats_resolution$unique_classes, 
                     class_stats_angle$unique_classes))

# Create Figure 2a: Classes by resolution
p2a <- ggplot(class_stats_resolution, aes(x = resolution, y = unique_classes)) +
  geom_point(size = 3) +
  geom_line(linewidth = 1) +
  theme_minimal() +
  labs(title = "a)",
       x = "Resolution (m)", 
       y = "Number of Unique Classes") +
  scale_y_continuous(limits = c(0, max_classes + 5)) +
  scale_x_continuous(trans = "log10") +
  theme(text = element_text(size = 12),
        axis.text = element_text(size = 10),
        plot.title = element_text(face = "bold", size = 14))

# Create Figure 2b: Classes by angle
p2b <- ggplot(class_stats_angle, aes(x = angle, y = unique_classes)) +
  geom_point(size = 3) +
  geom_line(linewidth = 1) +
  theme_minimal() +
  labs(title = "b)",
       x = "Angle (degrees)", 
       y = "Number of Unique Classes") +
  scale_y_continuous(limits = c(0, max_classes + 5)) +
  theme(text = element_text(size = 12),
        axis.text = element_text(size = 10),
        plot.title = element_text(face = "bold", size = 14))

# Combine and save
figure2 <- grid.arrange(p2a, p2b, ncol = 2)
ggsave(file.path(output_dir, "Figure2_unique_classes.png"), 
       figure2, width = 12, height = 5, dpi = 300)
cat("Figure 2 saved\n")

#' ============================================================================
#' FIGURE 3: RANKING OF TOP 5 STURLA CLASSES (HEATMAPS)
#' ============================================================================

cat("\n=== CREATING FIGURE 3 ===\n")
cat("Heatmaps showing ranking of top STURLA classes\n")

# Get top 5 classes for each resolution (at angle 0)
top_classes_resolution <- rankings %>%
  filter(angle == 0) %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "rank") %>%
  filter(!is.na(rank)) %>%
  group_by(resolution) %>%
  arrange(rank) %>%
  slice_head(n = 5) %>%
  ungroup()

# Get top 5 classes at 100m for all angles
top5_at_100m <- rankings %>%
  filter(resolution == 100, angle == 0) %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "rank") %>%
  filter(!is.na(rank)) %>%
  arrange(rank) %>%
  slice_head(n = 5) %>%
  pull(class)

top_classes_angle <- rankings %>%
  filter(resolution == 100) %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "rank") %>%
  filter(!is.na(rank), class %in% top5_at_100m) %>%
  ungroup()

# Create heatmap for resolution (Figure 3a)
p3a <- ggplot(top_classes_resolution, 
              aes(x = factor(resolution), y = reorder(class, -rank), fill = rank)) +
  geom_tile() +
  scale_fill_viridis(discrete = FALSE, direction = -1, name = "Rank") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
        axis.text.y = element_text(size = 9),
        text = element_text(size = 11),
        plot.title = element_text(face = "bold", size = 13)) +
  labs(title = "a)",
       x = "Resolution (m)",
       y = "STURLA Class")

# Create heatmap for angle (Figure 3b)
p3b <- ggplot(top_classes_angle, 
              aes(x = factor(angle), y = reorder(class, -rank), fill = rank)) +
  geom_tile() +
  scale_fill_viridis(discrete = FALSE, direction = -1, name = "Rank") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
        axis.text.y = element_text(size = 9),
        text = element_text(size = 11),
        plot.title = element_text(face = "bold", size = 13)) +
  labs(title = "b)",
       x = "Angle (degrees)",
       y = "STURLA Class")

# Combine and save
figure3 <- grid.arrange(p3a, p3b, ncol = 2)
ggsave(file.path(output_dir, "Figure3_top_classes_ranking.png"), 
       figure3, width = 14, height = 6, dpi = 300)
cat("Figure 3 saved\n")

#' ============================================================================
#' FIGURE 4: RANK DYNAMICS
#' ============================================================================

cat("\n=== CREATING FIGURE 4 ===\n")
cat("Rank dynamics showing how class abundance changes with scale\n")

# Identify consistently top-ranked classes across resolutions
class_consistency_resolution <- top_classes_resolution %>%
  group_by(class) %>%
  summarise(occurrences = n(), avg_rank = mean(rank)) %>%
  arrange(desc(occurrences), avg_rank)

top_5_classes <- head(class_consistency_resolution, 5)$class

# Track rank changes for top 5 classes across resolutions
rank_changes_resolution <- rankings %>%
  filter(angle == 0) %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "rank") %>%
  filter(class %in% top_5_classes, !is.na(rank))

# Track rank changes for top 5 classes at 100m across angles
rank_changes_angle <- rankings %>%
  filter(resolution == 100) %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "rank") %>%
  filter(class %in% top5_at_100m, !is.na(rank))

# Create Figure 4a: Rank dynamics by resolution
p4a <- ggplot(rank_changes_resolution, aes(x = resolution, y = rank, color = class)) +
  geom_line(linewidth = 2) +
  geom_point(size = 4) +
  scale_y_reverse() +
  scale_x_continuous(trans = "log10") +
  theme_minimal() +
  labs(title = "a)",
       x = "Resolution (m)",
       y = "Rank",
       color = "STURLA Class") +
  theme(text = element_text(size = 18),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 18),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 17),
        legend.position = "right",
        plot.title = element_text(face = "bold", size = 20))

# Create Figure 4b: Rank dynamics by angle
p4b <- ggplot(rank_changes_angle, aes(x = angle, y = rank, color = class)) +
  geom_line(linewidth = 2) +
  geom_point(size = 4) +
  scale_y_reverse() +
  theme_minimal() +
  labs(title = "b)",
       x = "Angle (degrees)",
       y = "Rank",
       color = "STURLA Class") +
  theme(text = element_text(size = 18),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 18),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 17),
        legend.position = "right",
        plot.title = element_text(face = "bold", size = 20))

# Combine and save
figure4 <- grid.arrange(p4a, p4b, ncol = 2)
ggsave(file.path(output_dir, "Figure4_rank_dynamics.png"), 
       figure4, width = 18, height = 7, dpi = 300)
cat("Figure 4 saved\n")

#' ============================================================================
#' FIGURE 5: CLASS COMPOSITION AND DIVERSITY (STACKED BAR CHARTS)
#' ============================================================================

cat("\n=== CREATING FIGURE 5 ===\n")
cat("Class composition showing land cover distribution across scales\n")

# Prepare data for stacked bar chart
counts_long <- counts %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "count") %>%
  mutate(count = replace_na(count, 0)) %>%
  group_by(resolution, class) %>%
  summarise(total_count = sum(count, na.rm = TRUE), .groups = "drop") %>%
  group_by(resolution) %>%
  mutate(total = sum(total_count),
         percentage = (total_count / total) * 100) %>%
  ungroup()

# Identify top 10 classes overall
top_10_classes <- counts_long %>%
  group_by(class) %>%
  summarise(total_percentage = sum(percentage)) %>%
  arrange(desc(total_percentage)) %>%
  slice_head(n = 10) %>%
  pull(class)

# Group other classes as "Other"
counts_long_grouped <- counts_long %>%
  mutate(class_grouped = ifelse(class %in% top_10_classes, class, "Other")) %>%
  group_by(resolution, class_grouped) %>%
  summarise(percentage = sum(percentage), .groups = "drop")

# Count unique classes per resolution
unique_counts <- counts %>%
  group_by(resolution) %>%
  summarise(across(all_of(names(counts)[!names(counts) %in% c("angle", "resolution")]), 
                   ~sum(. > 0, na.rm = TRUE)), .groups = "drop") %>%
  pivot_longer(cols = -resolution) %>%
  filter(value > 0) %>%
  group_by(resolution) %>%
  summarise(n_classes = n_distinct(name), .groups = "drop")

# Create color palette
n_colors <- length(unique(counts_long_grouped$class_grouped))
color_palette <- colorRampPalette(brewer.pal(min(12, n_colors), "Set3"))(n_colors)

# Scaling factor for dual axes
max_percentage <- 100
max_classes <- max(unique_counts$n_classes)
scale_factor <- max_percentage / max_classes

# Create Figure 5a: Composition by resolution with diversity overlay
p5a <- ggplot(counts_long_grouped, aes(x = factor(resolution), y = percentage, fill = class_grouped)) +
  geom_col(position = "stack") +
  geom_point(data = unique_counts, 
             aes(x = factor(resolution), y = n_classes * scale_factor, fill = NULL), 
             shape = 21, size = 3, color = "black", fill = "white") +
  geom_line(data = unique_counts, 
            aes(x = factor(resolution), y = n_classes * scale_factor, group = 1, fill = NULL), 
            color = "black", linewidth = 1) +
  scale_y_continuous(
    name = "Class Composition (%)",
    sec.axis = sec_axis(~ . / scale_factor, name = "Number of Unique Classes")
  ) +
  theme_minimal() +
  labs(title = "a)",
       x = "Resolution (m)",
       fill = "STURLA Class") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
        legend.position = "right",
        legend.key.size = unit(0.5, "lines"),
        text = element_text(size = 11),
        plot.title = element_text(face = "bold", size = 13),
        axis.title.y.right = element_text(color = "black"),
        axis.text.y.right = element_text(color = "black")) +
  scale_fill_manual(values = color_palette)

# Create Figure 5b: Composition by angle at 100m resolution
counts_long_angle <- counts %>%
  filter(resolution == 100) %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "count") %>%
  mutate(count = replace_na(count, 0)) %>%
  group_by(angle, class) %>%
  summarise(total_count = sum(count, na.rm = TRUE), .groups = "drop") %>%
  group_by(angle) %>%
  mutate(total = sum(total_count),
         percentage = (total_count / total) * 100) %>%
  ungroup() %>%
  mutate(class_grouped = ifelse(class %in% top_10_classes, class, "Other")) %>%
  group_by(angle, class_grouped) %>%
  summarise(percentage = sum(percentage), .groups = "drop")

p5b <- ggplot(counts_long_angle, aes(x = factor(angle), y = percentage, fill = class_grouped)) +
  geom_col(position = "stack") +
  theme_minimal() +
  labs(title = "b)",
       x = "Angle (degrees)",
       y = "Class Composition (%)",
       fill = "STURLA Class") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
        legend.position = "none",
        text = element_text(size = 11),
        plot.title = element_text(face = "bold", size = 13)) +
  scale_fill_manual(values = color_palette)

# Combine and save
figure5 <- grid.arrange(p5a, p5b, ncol = 2, widths = c(2, 1))
ggsave(file.path(output_dir, "Figure5_class_composition.png"), 
       figure5, width = 16, height = 6, dpi = 300)
cat("Figure 5 saved\n")

#' ============================================================================
#' FIGURE 6: CLASS STABILITY ANALYSIS (3 PANELS)
#' ============================================================================

cat("\n=== CREATING FIGURE 6 ===\n")
cat("Class stability metrics across resolutions\n")

# Panel 6a: Shannon Diversity Index
diversity_by_resolution <- counts %>%
  group_by(resolution) %>%
  summarise(across(all_of(names(counts)[!names(counts) %in% c("angle", "resolution")]), 
                   sum, na.rm = TRUE), .groups = "drop") %>%
  pivot_longer(cols = -resolution, names_to = "class", values_to = "count") %>%
  filter(count > 0) %>%
  group_by(resolution) %>%
  summarise(diversity = diversity(count, index = "shannon"), .groups = "drop")

# Panel 6b: Classes needed for coverage quartiles
dominant_classes <- counts %>%
  group_by(resolution) %>%
  summarise(across(all_of(names(counts)[!names(counts) %in% c("angle", "resolution")]), 
                   sum, na.rm = TRUE), .groups = "drop") %>%
  pivot_longer(cols = -resolution, names_to = "class", values_to = "count") %>%
  filter(count > 0) %>%
  group_by(resolution) %>%
  arrange(desc(count)) %>%
  mutate(total = sum(count),
         proportion = count / total,
         cumulative_prop = cumsum(proportion),
         rank = row_number()) %>%
  summarise(
    classes_25percent = min(which(cumulative_prop >= 0.25)),
    classes_50percent = min(which(cumulative_prop >= 0.50)),
    classes_75percent = min(which(cumulative_prop >= 0.75)),
    classes_90percent = min(which(cumulative_prop >= 0.90)),
    .groups = "drop"
  )

# Panel 6c: Class presence matrix
class_presence <- counts %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "count") %>%
  group_by(resolution, class) %>%
  summarise(present = any(count > 0, na.rm = TRUE), .groups = "drop")

# Create Figure 6a: Shannon Diversity
p6a <- ggplot(diversity_by_resolution, aes(x = resolution, y = diversity)) +
  geom_line(linewidth = 1.2, color = "blue") +
  geom_point(size = 3, color = "blue") +
  scale_x_continuous(trans = "log10") +
  theme_minimal() +
  labs(title = "a)",
       x = "Resolution (m)",
       y = "Shannon Diversity Index") +
  theme(text = element_text(size = 11),
        plot.title = element_text(face = "bold", size = 13))

# Create Figure 6b: Coverage quartiles
p6b_data <- dominant_classes %>%
  pivot_longer(cols = c(classes_25percent, classes_50percent, classes_75percent, classes_90percent),
               names_to = "quartile",
               values_to = "n_classes") %>%
  mutate(quartile = factor(quartile, 
                           levels = c("classes_25percent", "classes_50percent", 
                                      "classes_75percent", "classes_90percent"),
                           labels = c("25%", "50%", "75%", "90%")))

p6b <- ggplot(p6b_data, aes(x = resolution, y = n_classes, color = quartile)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 3) +
  scale_x_continuous(trans = "log10") +
  scale_color_viridis_d(name = "Coverage") +
  theme_minimal() +
  labs(title = "b)",
       x = "Resolution (m)",
       y = "Number of Classes") +
  theme(text = element_text(size = 11),
        plot.title = element_text(face = "bold", size = 13))

# Create Figure 6c: Class presence matrix (simplified for clarity)
unique_classes <- unique(class_presence$class)
class_labels <- rep("", length(unique_classes))
class_labels[seq(1, length(unique_classes), 3)] <- unique_classes[seq(1, length(unique_classes), 3)]

p6c <- ggplot(class_presence, aes(x = factor(resolution), y = class, fill = present)) +
  geom_tile() +
  scale_fill_manual(values = c("FALSE" = "white", "TRUE" = "blue"), 
                    name = "Present",
                    labels = c("FALSE" = "No", "TRUE" = "Yes")) +
  scale_y_discrete(labels = class_labels) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 7),
        axis.text.y = element_text(size = 4),
        text = element_text(size = 10),
        plot.title = element_text(face = "bold", size = 13)) +
  labs(title = "c)",
       x = "Resolution (m)",
       y = "STURLA Classes")

# Combine all panels
figure6 <- grid.arrange(p6a, p6b, p6c, layout_matrix = rbind(c(1, 2), c(3, 3)))
ggsave(file.path(output_dir, "Figure6_class_stability.png"), 
       figure6, width = 12, height = 10, dpi = 300)
cat("Figure 6 saved\n")

#' ============================================================================
#' FIGURE 7: MEAN SURFACE TEMPERATURE BY STURLA CLASS (HEATMAPS)
#' ============================================================================

cat("\n=== CREATING FIGURE 7 ===\n")
cat("Temperature patterns across STURLA classes\n")

# Calculate mean temperature for each class
temp_summary <- temps %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "temp") %>%
  group_by(resolution, angle, class) %>%
  summarise(
    mean_temp = mean(temp, na.rm = TRUE),
    n_obs = sum(!is.na(temp)),
    .groups = "drop"
  ) %>%
  filter(n_obs > 0)

# Select representative classes for visualization
selected_classes <- c("TGPL", "TGPLM", "TGPLMH", "TGBWPLMH", "P", "PL", 
                      "PLM", "PLMH", "W", "TGW", "GW", "T", "G", "TG")

# Create temperature heatmap for resolution (Figure 7a)
p7a <- temp_summary %>%
  filter(angle == 0, class %in% selected_classes) %>%
  ggplot(aes(x = factor(resolution), y = class, fill = mean_temp)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdYlBu", direction = -1, 
                       name = "Temp (°C)", na.value = "white") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
        axis.text.y = element_text(size = 9),
        text = element_text(size = 11),
        plot.title = element_text(face = "bold", size = 13)) +
  labs(title = "a)",
       x = "Resolution (m)",
       y = "STURLA Class")

# Create temperature heatmap for angle (Figure 7b)
p7b <- temp_summary %>%
  filter(resolution == 100, class %in% selected_classes) %>%
  ggplot(aes(x = factor(angle), y = class, fill = mean_temp)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdYlBu", direction = -1, 
                       name = "Temp (°C)", na.value = "white") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
        axis.text.y = element_text(size = 9),
        text = element_text(size = 11),
        plot.title = element_text(face = "bold", size = 13)) +
  labs(title = "b)",
       x = "Angle (degrees)",
       y = "STURLA Class")

# Combine and save
figure7 <- grid.arrange(p7a, p7b, ncol = 2)
ggsave(file.path(output_dir, "Figure7_temperature_heatmap.png"), 
       figure7, width = 14, height = 6, dpi = 300)
cat("Figure 7 saved\n")

#' ============================================================================
#' FIGURE 8: R-SQUARED ANALYSIS (INCLUDING 60-90m RESOLUTIONS)
#' ============================================================================

cat("\n=== CREATING FIGURE 8 ===\n")
cat("Temperature prediction performance across resolutions\n")

# Prepare combined data
temps_long <- temps %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "temp")

counts_long_r2 <- counts %>%
  pivot_longer(cols = -c(angle, resolution), names_to = "class", values_to = "count")

combined_data <- counts_long_r2 %>%
  left_join(temps_long, by = c("angle", "resolution", "class")) %>%
  filter(!is.na(temp), !is.na(count), count > 0) %>%
  filter(resolution >= 60)  # Landsat 7 thermal native resolution is 60m

# Function to calculate R-squared for each resolution
predict_temp <- function(data, resolution_value) {
  data_subset <- data %>% filter(resolution == resolution_value)
  
  # Need sufficient data and class diversity
  if(n_distinct(data_subset$class) < 2 || nrow(data_subset) < 10) {
    return(NA)
  }
  
  # Fit linear model: temperature predicted by STURLA class
  model <- lm(temp ~ class, data = data_subset)
  return(summary(model)$r.squared)
}

# Calculate R-squared for each resolution
resolutions <- sort(unique(combined_data$resolution))
prediction_performance <- tibble(
  resolution = resolutions,
  r_squared = map_dbl(resolutions, ~predict_temp(combined_data, .))
) %>%
  filter(!is.na(r_squared))

# Find optimal range (where R² exceeds 95% of maximum)
max_r2 <- max(prediction_performance$r_squared)
optimal_threshold <- max_r2 * 0.95
optimal_range <- prediction_performance %>%
  filter(r_squared >= optimal_threshold) %>%
  summarise(min_res = min(resolution), max_res = max(resolution))

cat(sprintf("  Maximum R²: %.4f at %dm resolution\n", 
            max_r2, 
            prediction_performance$resolution[which.max(prediction_performance$r_squared)]))
cat(sprintf("  Optimal range (≥95%% of max): %d-%dm\n", 
            optimal_range$min_res, optimal_range$max_res))

# Create Figure 8: R² by resolution with optimal range highlighted
p8 <- ggplot(prediction_performance, aes(x = resolution, y = r_squared)) +
  # Add shaded optimal range
  geom_rect(data = optimal_range,
            aes(xmin = min_res, xmax = max_res, ymin = -Inf, ymax = Inf),
            fill = "lightgray", alpha = 0.5, inherit.aes = FALSE) +
  # Add line and points
  geom_line(linewidth = 1.5, color = "darkblue") +
  geom_point(size = 3, color = "darkblue") +
  # Add threshold line
  geom_hline(yintercept = optimal_threshold, linetype = "dashed", color = "red") +
  # Format axes
  scale_x_continuous(trans = "log10", 
                     breaks = c(60, 70, 80, 90, 100, 200, 500, 1000, 5000, 10000)) +
  theme_minimal() +
  labs(x = "Resolution (m)", 
       y = expression(R^2)) +
  theme(text = element_text(size = 12),
        axis.text = element_text(size = 11)) +
  # Add annotation for optimal range
  annotate("text", x = 400, y = optimal_threshold + 0.02,
           label = paste0("Optimal range: ", optimal_range$min_res, "-", 
                          optimal_range$max_res, "m"),
           color = "red", size = 4)

ggsave(file.path(output_dir, "Figure8_r_squared.png"), 
       p8, width = 10, height = 6, dpi = 300)
cat("Figure 8 saved\n")

# Additional analysis for fine resolutions (60-90m)
cat("\n=== Fine Resolution Analysis (60-90m) ===\n")
fine_res_analysis <- prediction_performance %>%
  filter(resolution >= 60 & resolution < 100) %>%
  arrange(resolution)

if(nrow(fine_res_analysis) > 0) {
  print(fine_res_analysis)
  
  # Compare R² at key resolutions
  if(60 %in% prediction_performance$resolution & 100 %in% prediction_performance$resolution) {
    r2_60 <- prediction_performance$r_squared[prediction_performance$resolution == 60]
    r2_100 <- prediction_performance$r_squared[prediction_performance$resolution == 100]
    
    cat(sprintf("\nR² at 60m: %.4f\n", r2_60))
    cat(sprintf("R² at 100m: %.4f\n", r2_100))
    cat(sprintf("Change from 60m to 100m: %.4f (%.1f%%)\n", 
                r2_100 - r2_60, ((r2_100/r2_60)-1)*100))
  }
} else {
  cat("No data available for 60-90m resolution range\n")
}

#' ============================================================================
#' FIGURE S1: CUMULATIVE PROPORTIONS (SUPPLEMENTARY)
#' ============================================================================

cat("\n=== CREATING FIGURE S1 (SUPPLEMENTARY) ===\n")
cat("Cumulative class coverage curves\n")

# Prepare data for cumulative proportions
cumulative_data <- counts %>%
  group_by(resolution) %>%
  summarise(across(all_of(names(counts)[!names(counts) %in% c("angle", "resolution")]), 
                   sum, na.rm = TRUE), .groups = "drop") %>%
  pivot_longer(cols = -resolution, names_to = "class", values_to = "count") %>%
  filter(count > 0) %>%
  group_by(resolution) %>%
  arrange(desc(count)) %>%
  mutate(total = sum(count),
         proportion = count / total,
         cumulative_prop = cumsum(proportion),
         rank = row_number()) %>%
  ungroup()

# Create cumulative proportion curves for selected resolutions
pS1 <- cumulative_data %>%
  filter(resolution %in% c(10, 50, 100, 500, 1000, 5000, 10000)) %>%
  ggplot(aes(x = rank, y = cumulative_prop, color = factor(resolution))) +
  geom_line(linewidth = 1.2) +
  geom_hline(yintercept = c(0.25, 0.50, 0.75, 0.90), 
             linetype = "dashed", alpha = 0.5) +
  scale_color_viridis_d(name = "Resolution (m)") +
  theme_minimal() +
  labs(title = "Cumulative Proportion of Area by Class Rank",
       x = "Class Rank",
       y = "Cumulative Proportion") +
  theme(text = element_text(size = 11),
        legend.position = "right") +
  annotate("text", x = 50, y = c(0.25, 0.50, 0.75, 0.90), 
           label = c("25%", "50%", "75%", "90%"), 
           hjust = -0.2, size = 3)

ggsave(file.path(output_dir, "FigureS1_cumulative_proportions.png"), 
       pS1, width = 10, height = 6, dpi = 300)
cat("Figure S1 saved\n")

#' ============================================================================
#' SUMMARY OUTPUT
#' ============================================================================

cat("\n=== ANALYSIS COMPLETE ===\n")
cat("Completed at:", format(Sys.time(), "%Y-%